<!DOCTYPE html>
<html>
<head>
  <title>Cookie Heist Maze - Viewer</title>
  <link rel="stylesheet" href="styles.css">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    .stage-container {
      text-align: center;
      padding: 20px;
      margin-bottom: 20px;
    }

    .join-section {
      text-align: center;
      padding: 20px 0;
      background: rgba(255, 255, 255, 0.9);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .join-button {
      display: inline-block;
      padding: 15px 40px;
      font-size: 24px;
      font-weight: bold;
      text-decoration: none;
      color: white;
      background-color: #4CAF50;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }

    .join-button:hover {
      background-color: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
    }

    .game-container {
      padding-top: 100px;
    }

    .game-stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      text-align: center;
      z-index: 1000;
    }

    .winner-animation {
      animation: celebrate 1s ease-in-out infinite;
    }

    @keyframes celebrate {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .stats-table {
      width: 100%;
      margin: 20px 0;
      border-collapse: collapse;
    }

    .stats-table td, .stats-table th {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    .rules-section {
      margin: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
    }

    #qr-code {
      margin: 20px auto;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Stage containers -->
  <div id="lobby-stage" class="stage-container" style="display: none;">
    <h1>Welcome to Cookie Heist Maze!</h1>
    <div class="rules-section">
      <h2>Game Rules</h2>
      <p>Collect cookies, avoid traps, and be the first to win!</p>
      <ul>
        <li>Use arrow keys or WASD to move</li>
        <li>Space to place trap cookies</li>
        <li>Collect normal cookies to score points</li>
        <li>Avoid trap cookies or lose lives</li>
      </ul>
    </div>
    <div id="qr-code"></div>
  </div>

  <div class="game-container">
    <div class="game-header">
      <div class="player-stats">
        <div id="player1-stats" class="player-box">
          <h3>Player 1</h3>
          <div>Lives: <span id="p1-lives">3</span></div>
          <div>Score: <span id="p1-score">0</span></div>
        </div>
        <div id="game-status">Waiting for players...</div>
        <div id="player2-stats" class="player-box">
          <h3>Player 2</h3>
          <div>Lives: <span id="p2-lives">3</span></div>
          <div>Score: <span id="p2-score">0</span></div>
        </div>
      </div>
      
      <div class="game-stats" id="game-stats" style="display: none;">
        <div>Time: <span id="game-time">00:00</span></div>
        <div>Cookies Collected: <span id="total-cookies">0</span></div>
        <div>Traps Placed: <span id="total-traps">0</span></div>
      </div>
    </div>
    
    <div id="maze-container">
      <canvas id="mazeCanvas"></canvas>
    </div>
    
    <div id="join-section">
      <a id="player-link" class="join-button" target="_blank">Play Game</a>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over" class="game-over" style="display: none;">
      <h2 id="winner-announcement" class="winner-animation"></h2>
      <table class="stats-table">
        <tr>
          <th>Stat</th>
          <th>Player 1</th>
          <th>Player 2</th>
        </tr>
        <tr>
          <td>Final Score</td>
          <td id="p1-final-score">0</td>
          <td id="p2-final-score">0</td>
        </tr>
        <tr>
          <td>Cookies Collected</td>
          <td id="p1-cookies">0</td>
          <td id="p2-cookies">0</td>
        </tr>
        <tr>
          <td>Traps Placed</td>
          <td id="p1-traps">0</td>
          <td id="p2-traps">0</td>
        </tr>
      </table>
      <div>Game Duration: <span id="final-time">00:00</span></div>
      <button id="play-again" class="join-button">Play Again</button>
      <button id="view-replay" class="join-button">View Replay</button>
    </div>
  </div>

  <script>
    const gameId = window.location.pathname.split('/').pop();
    const socket = io('/maze');
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = null;
    let gameStartTime = null;
    let gameTimer = null;

    // Set up player links
    const baseUrl = window.location.origin;
    document.getElementById('player-link').href = `${baseUrl}/maze/player/${gameId}`;

    // Connect to game
    socket.on('connect', () => {
      // Store game state in session storage to handle refreshes
      const storedState = sessionStorage.getItem(`gameState_${gameId}`);
      if (storedState) {
        try {
          const savedState = JSON.parse(storedState);
          gameState = savedState;
          gameStartTime = savedState.startTime || null;
          if (gameStartTime && savedState.state === 'playing') {
            startGameTimer();
          }
          updateUI();
        } catch (e) {
          console.error('Error restoring game state:', e);
        }
      }

      socket.emit('join_game', {
        gameId,
        role: 'viewer'
      });
    });

    // Game state updates
    socket.on('game_state', (state) => {
      gameState = state;
      // Save game state to session storage
      sessionStorage.setItem(`gameState_${gameId}`, JSON.stringify({
        ...state,
        startTime: gameStartTime
      }));
      
      updateUI();
      if (state.state === 'playing') {
        if (!gameStartTime) {
          gameStartTime = Date.now();
          startGameTimer();
          // Update stored state with start time
          sessionStorage.setItem(`gameState_${gameId}`, JSON.stringify({
            ...state,
            startTime: gameStartTime
          }));
        }
        const mazeContainer = document.getElementById('maze-container');
        mazeContainer.style.display = 'block';
        drawGame();
      }
    });

    socket.on('player_joined', ({ gameState: state }) => {
      updateGameState(state);
    });

    socket.on('game_over', (finalState) => {
      gameState = finalState;
      // Clear session storage on game over
      sessionStorage.removeItem(`gameState_${gameId}`);
      showGameOver();
    });

    socket.on('error', (error) => {
      console.error('Socket error:', error);
      alert(error.message);
    });

    // Handle disconnection
    socket.on('disconnect', () => {
      // Save current state before disconnection
      if (gameState) {
        sessionStorage.setItem(`gameState_${gameId}`, JSON.stringify({
          ...gameState,
          startTime: gameStartTime
        }));
      }
    });

    function updateGameState(state) {
      gameState = state;
      updateUI();
    }

    function startGameTimer() {
      if (gameTimer) clearInterval(gameTimer);
      gameTimer = setInterval(updateGameTime, 1000);
    }

    function updateGameTime() {
      if (!gameStartTime) return;
      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('game-time').textContent = `${minutes}:${seconds}`;
    }

    function showGameOver() {
      clearInterval(gameTimer);
      const gameOver = document.getElementById('game-over');
      const winner = gameState.players.find(p => p.score >= gameState.config.cookiesToWin);
      
      document.getElementById('winner-announcement').textContent = winner ? 
        `Player ${gameState.players.indexOf(winner) + 1} Wins!` : 'Game Over!';
      
      // Update final stats
      document.getElementById('p1-final-score').textContent = gameState.players[0]?.score || 0;
      document.getElementById('p2-final-score').textContent = gameState.players[1]?.score || 0;
      document.getElementById('p1-cookies').textContent = gameState.players[0]?.cookiesCollected || 0;
      document.getElementById('p2-cookies').textContent = gameState.players[1]?.cookiesCollected || 0;
      document.getElementById('p1-traps').textContent = gameState.players[0]?.trapsPlaced || 0;
      document.getElementById('p2-traps').textContent = gameState.players[1]?.trapsPlaced || 0;
      
      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('final-time').textContent = `${minutes}:${seconds}`;
      
      gameOver.style.display = 'block';
    }

    function resetGame() {
      socket.emit('reset_game', { gameId });
      document.getElementById('game-over').style.display = 'none';
      gameStartTime = null;
      if (gameTimer) clearInterval(gameTimer);
      updateUI();
    }

    document.getElementById('play-again').addEventListener('click', resetGame);
    document.getElementById('view-replay').addEventListener('click', () => {
      // Implement replay functionality
      socket.emit('request_replay', { gameId });
    });

    function updateUI() {
      const statusElem = document.getElementById('game-status');
      const joinSection = document.getElementById('join-section');
      const lobbyStage = document.getElementById('lobby-stage');
      const gameStats = document.getElementById('game-stats');
      
      if (!gameState) {
        statusElem.textContent = 'Connecting...';
        return;
      }

      // Update player stats
      if (gameState.players[0]) {
        document.getElementById('p1-lives').textContent = gameState.players[0].lives;
        document.getElementById('p1-score').textContent = gameState.players[0].score;
      }
      
      if (gameState.players[1]) {
        document.getElementById('p2-lives').textContent = gameState.players[1].lives;
        document.getElementById('p2-score').textContent = gameState.players[1].score;
      }

      // Update game status and visibility
      switch(gameState.state) {
        case 'waiting':
          statusElem.textContent = `Waiting for players... (${gameState.players.length}/2)`;
          joinSection.style.display = gameState.players.length < 2 ? 'block' : 'none';
          lobbyStage.style.display = gameState.players.length === 0 ? 'block' : 'none';
          gameStats.style.display = 'none';
          break;
        case 'playing':
          statusElem.textContent = 'Game in progress';
          joinSection.style.display = 'none';
          lobbyStage.style.display = 'none';
          gameStats.style.display = 'block';
          document.getElementById('total-cookies').textContent = 
            gameState.players.reduce((sum, p) => sum + (p.cookiesCollected || 0), 0);
          document.getElementById('total-traps').textContent = 
            gameState.players.reduce((sum, p) => sum + (p.trapsPlaced || 0), 0);
          break;
        case 'finished':
          statusElem.textContent = 'Game Over!';
          joinSection.style.display = 'none';
          lobbyStage.style.display = 'none';
          gameStats.style.display = 'none';
          break;
      }
    }

    function drawGame() {
      if (!gameState) return;
      
      // Set canvas size based on maze size
      const tileSize = Math.min(
        window.innerWidth / gameState.maze[0].length,
        window.innerHeight / gameState.maze.length
      );
      canvas.width = gameState.maze[0].length * tileSize;
      canvas.height = gameState.maze.length * tileSize;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw maze
      for (let y = 0; y < gameState.maze.length; y++) {
        for (let x = 0; x < gameState.maze[y].length; x++) {
          const tile = gameState.maze[y][x];
          ctx.fillStyle = tile === 1 ? '#333' : '#fff';
          ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          
          // Draw grid lines
          ctx.strokeStyle = '#ddd';
          ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
          
          // Draw cookies and traps
          if (tile === 0) {
            const cookie = gameState.cookies.find(c => c.x === x && c.y === y);
            const trap = gameState.trapCookies.find(t => t.x === x && t.y === y);
            
            if (cookie) {
              ctx.fillStyle = '#FFD700';
              ctx.beginPath();
              ctx.arc(
                (x + 0.5) * tileSize,
                (y + 0.5) * tileSize,
                tileSize * 0.3,
                0,
                Math.PI * 2
              );
              ctx.fill();
            } else if (trap) {
              // Draw trap (glowing if recently placed)
              const isGlowing = Date.now() - trap.placedTime < 3000;
              ctx.fillStyle = isGlowing ? '#FF6B6B' : '#FFD700';
              ctx.beginPath();
              ctx.arc(
                (x + 0.5) * tileSize,
                (y + 0.5) * tileSize,
                tileSize * 0.3,
                0,
                Math.PI * 2
              );
              ctx.fill();
              
              if (isGlowing) {
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.stroke();
              }
            }
          }
        }
      }
      
      // Draw players
      gameState.players.forEach((player, index) => {
        ctx.fillStyle = index === 0 ? '#4CAF50' : '#2196F3';
        ctx.beginPath();
        ctx.arc(
          (player.x + 0.5) * tileSize,
          (player.y + 0.5) * tileSize,
          tileSize * 0.4,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      if (gameState) {
        drawGame();
      }
    });

    // Start animation loop
    function gameLoop() {
      if (gameState && gameState.state === 'playing') {
        drawGame();
      }
      requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
  </script>
</body>
</html>