<!DOCTYPE html>
<html>
<head>
  <title>Cookie Heist Maze - Viewer</title>
  <link rel="stylesheet" href="styles.css">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    .join-section {
      text-align: center;
      padding: 20px 0;
      background: rgba(255, 255, 255, 0.9);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .join-button {
      display: inline-block;
      padding: 15px 40px;
      font-size: 24px;
      font-weight: bold;
      text-decoration: none;
      color: white;
      background-color: #4CAF50;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }

    .join-button:hover {
      background-color: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
    }

    .game-container {
      padding-top: 100px; /* Make space for fixed join-section */
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <div class="player-stats">
        <div id="player1-stats" class="player-box">
          <h3>Player 1</h3>
          <div>Lives: <span id="p1-lives">3</span></div>
          <div>Score: <span id="p1-score">0</span></div>
        </div>
        <div id="game-status">Waiting for players...</div>
        <div id="player2-stats" class="player-box">
          <h3>Player 2</h3>
          <div>Lives: <span id="p2-lives">3</span></div>
          <div>Score: <span id="p2-score">0</span></div>
        </div>
      </div>
    </div>
    
    <div id="maze-container">
      <canvas id="mazeCanvas"></canvas>
    </div>
    
    <div id="join-section">
      <a id="player-link" class="join-button" target="_blank">Play Game</a>
    </div>
  </div>

  <script>
    const gameId = window.location.pathname.split('/').pop();
    const socket = io('/maze');
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = null;

    // Set up player links
    const baseUrl = window.location.origin;
    document.getElementById('player-link').href = `${baseUrl}/maze/player/${gameId}`;

    // Connect to game
    socket.on('connect', () => {
      socket.emit('join_game', {
        gameId,
        role: 'viewer'
      });
    });

    // Game state updates
    socket.on('game_state', (state) => {
      gameState = state;
      updateUI();
      drawGame();
    });

    socket.on('player_joined', ({ gameState: state }) => {
      updateGameState(state);
    });

    socket.on('error', (error) => {
      console.error('Socket error:', error);
      alert(error.message);
    });

    function updateGameState(state) {
      gameState = state;
      updateUI();
    }

    function updateUI() {
      const statusElem = document.getElementById('game-status');
      const joinSection = document.getElementById('join-section');
      
      if (!gameState) {
        statusElem.textContent = 'Connecting...';
        return;
      }

      // Update player stats
      if (gameState.players[0]) {
        document.getElementById('p1-lives').textContent = gameState.players[0].lives;
        document.getElementById('p1-score').textContent = gameState.players[0].score;
        document.getElementById('player1-link').style.display = 'none';
      }
      
      if (gameState.players[1]) {
        document.getElementById('p2-lives').textContent = gameState.players[1].lives;
        document.getElementById('p2-score').textContent = gameState.players[1].score;
        document.getElementById('player2-link').style.display = 'none';
      }

      // Update game status
      switch(gameState.state) {
        case 'waiting':
          statusElem.textContent = `Waiting for players... (${gameState.players.length}/2)`;
          joinSection.style.display = gameState.players.length < 2 ? 'block' : 'none';
          break;
        case 'playing':
          statusElem.textContent = 'Game in progress';
          joinSection.style.display = 'none';
          break;
        case 'finished':
          const winner = gameState.players.find(p => p.score >= gameState.config.cookiesToWin);
          statusElem.textContent = winner ? 
            `Game Over! Player ${gameState.players.indexOf(winner) + 1} wins!` :
            'Game Over!';
          joinSection.style.display = 'none';
          break;
      }
    }

    function drawGame() {
      if (!gameState) return;
      
      // Set canvas size based on maze size
      const tileSize = Math.min(
        window.innerWidth / gameState.maze[0].length,
        window.innerHeight / gameState.maze.length
      );
      canvas.width = gameState.maze[0].length * tileSize;
      canvas.height = gameState.maze.length * tileSize;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw maze
      for (let y = 0; y < gameState.maze.length; y++) {
        for (let x = 0; x < gameState.maze[y].length; x++) {
          const tile = gameState.maze[y][x];
          ctx.fillStyle = tile === 1 ? '#333' : '#fff';
          ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          
          // Draw cookies and traps
          if (tile === 0) {
            const cookie = gameState.cookies.find(c => c.x === x && c.y === y);
            const trap = gameState.trapCookies.find(t => t.x === x && t.y === y);
            
            if (cookie) {
              ctx.fillStyle = '#FFD700';
              ctx.beginPath();
              ctx.arc(
                (x + 0.5) * tileSize,
                (y + 0.5) * tileSize,
                tileSize * 0.3,
                0,
                Math.PI * 2
              );
              ctx.fill();
            } else if (trap) {
              // Draw trap (glowing if recently placed)
              const isGlowing = Date.now() - trap.placedTime < 3000;
              ctx.fillStyle = isGlowing ? '#FF6B6B' : '#FFD700';
              ctx.beginPath();
              ctx.arc(
                (x + 0.5) * tileSize,
                (y + 0.5) * tileSize,
                tileSize * 0.3,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Draw players
      gameState.players.forEach((player, index) => {
        ctx.fillStyle = index === 0 ? '#4CAF50' : '#F44336';
        ctx.beginPath();
        ctx.arc(
          (player.position.x + 0.5) * tileSize,
          (player.position.y + 0.5) * tileSize,
          tileSize * 0.4,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      if (gameState) {
        drawGame();
      }
    });

    // Start animation loop
    function gameLoop() {
      drawGame();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>