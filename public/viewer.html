<!-- public/viewer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>View Spin Wheel</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>Collaborative Spin Wheel</h1>
    <div id="canvas-container">
      <div id="pointer"></div>
      <canvas id="wheelCanvas" width="500" height="500"></canvas>
    </div>
    <p id="statusMessage" class="error"></p>
    <div id="winner" class="success"></div>
  </div>

  <!-- Include Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <script>
    const socket = io();

    // Extract wheelId from URL
    const pathParts = window.location.pathname.split('/');
    const wheelId = pathParts[pathParts.length - 1];

    // Join the wheel room
    socket.emit('joinWheel', wheelId);

    // Handle errors
    socket.on('error', (message) => {
      document.getElementById('statusMessage').innerText = message;
    });

    // Fetch wheel configuration
    fetch(`/wheel-config/${wheelId}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          document.getElementById('statusMessage').innerText = data.error;
        } else {
          initializeWheel(data.segments, data.colors);
        }
      })
      .catch(error => {
        console.error('Error:', error);
        document.getElementById('statusMessage').innerText = 'An error occurred while loading the wheel.';
      });

    // Function to initialize the wheel
    let spinning = false;
    function initializeWheel(segments, colors) {
      const canvas = document.getElementById('wheelCanvas');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 20;
      const numSegments = segments.length;
      const segmentAngle = 2 * Math.PI / numSegments;

      // Initial rotation to align 0 radians at the top
      let currentAngle = 0;

      function drawWheel(angleOffset = 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(angleOffset);
        ctx.translate(-centerX, -centerY);
        for (let i = 0; i < numSegments; i++) {
          const startAngle = i * segmentAngle;
          const endAngle = startAngle + segmentAngle;

          // Draw segment
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.closePath();
          ctx.fillStyle = colors[i];
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.stroke();

          // Draw text
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(startAngle + segmentAngle / 2);
          ctx.textAlign = 'right';
          ctx.fillStyle = '#FFFFFF'; // White text for contrast
          ctx.font = '20px Arial'; // Bigger font
          ctx.fillText(segments[i], radius - 10, 10);
          ctx.restore();
        }
        ctx.restore();
      }

      drawWheel();

      // Spin functionality
      let targetAngle = 0;
      let spinStartTime = null;
      let spinDuration = 0;
      let totalAngle = 0;
      let animationFrameId;

      // Handle spin events from the server
      socket.on('spin', (spinData) => {
        if (spinning) return; // Prevent multiple spins

        const { spins, duration, stopAngle, winningSegment } = spinData;
        spinDuration = duration * 1000; // Convert to milliseconds
        totalAngle = (spins * 2 * Math.PI) + (stopAngle * Math.PI / 180); // Total radians to spin

        targetAngle = currentAngle + totalAngle;

        spinStartTime = Date.now();
        spinning = true;
        document.getElementById('statusMessage').innerText = 'Spinning...';
        document.getElementById('winner').innerText = '';

        animateSpin();
      });

      // Handle spinEnded events to reset spin state
      socket.on('spinEnded', (spinData) => {
        spinning = false;
        document.getElementById('statusMessage').innerText = '';
      });

      // Animate the spin using setInterval with smooth deceleration
      function animateSpin() {
        const startTime = Date.now();
        const interval = 20; // milliseconds

        function easeOut(t) {
          return 1 - Math.pow(1 - t, 3); // Cubic easing out
        }

        const spinInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / spinDuration, 1); // Clamp to [0,1]
          const easedT = easeOut(t);
          currentAngle = easedT * totalAngle;

          drawWheel(currentAngle % (2 * Math.PI));

          if (t >= 1) {
            clearInterval(spinInterval);
            spinning = false;

            // Determine the winning segment
            const normalizedAngle = currentAngle % (2 * Math.PI);
            const winningSegmentIndex = Math.floor((2 * Math.PI - normalizedAngle) / segmentAngle) % numSegments;

            // Update the winner in the UI
            document.getElementById('winner').innerText = `The wheel stopped at: ${segments[winningSegmentIndex]}`;
            document.getElementById('statusMessage').innerText = '';
          }
        }, interval);
      }

      // Handle click on the wheel to initiate spin
      canvas.addEventListener('click', () => {
        if (!spinning) {
          socket.emit('spin', { wheelId });
        }
      });
    }

    // Function to generate random colors (unused now)
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }
  </script>
</body>
</html>
