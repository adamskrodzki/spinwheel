<!-- public/viewer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>View Spin Wheel</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <h1>Collaborative Spin Wheel</h1>
    <div id="canvas-container">
      <div id="pointer"></div>
      <canvas id="wheelCanvas" width="500" height="500"></canvas>
    </div>
    <p id="statusMessage" class="error"></p>
  </div>

  <!-- Include Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <script>
    const socket = io();

    // Extract wheelId from URL
    const pathParts = window.location.pathname.split('/');
    const wheelId = pathParts[pathParts.length - 1];

    // Join the wheel room
    socket.emit('joinWheel', wheelId);

    // Handle errors
    socket.on('error', (message) => {
      document.getElementById('statusMessage').innerText = message;
    });

    // Fetch wheel configuration
    fetch(`/wheel-config/${wheelId}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          document.getElementById('statusMessage').innerText = data.error;
        } else {
          initializeWheel(data.segments);
        }
      })
      .catch(error => {
        console.error('Error:', error);
        document.getElementById('statusMessage').innerText = 'An error occurred while loading the wheel.';
      });

    // Function to initialize the wheel
    let theWheel;
    let spinning = false;

    function initializeWheel(segments) {
      const canvas = document.getElementById('wheelCanvas');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 20;
      const numSegments = segments.length;
      const segmentAngle = 2 * Math.PI / numSegments;

      // Assign random colors to each segment
      const colors = segments.map(() => getRandomColor());

      // Draw the wheel
      function drawWheel(angleOffset = 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < numSegments; i++) {
          const startAngle = i * segmentAngle + angleOffset;
          const endAngle = startAngle + segmentAngle;

          // Draw segment
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.closePath();
          ctx.fillStyle = colors[i];
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.stroke();

          // Draw text
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(startAngle + segmentAngle / 2);
          ctx.textAlign = 'right';
          ctx.fillStyle = '#000';
          ctx.font = '16px Arial';
          ctx.fillText(segments[i], radius - 10, 10);
          ctx.restore();
        }
      }

      drawWheel();

      // Spin functionality
      let currentAngle = 0;
      let targetAngle = 0;
      let spinStartTime = null;
      let spinDuration = 0;
      let spinSpeed = 0;
      let animationFrameId;

      // Handle spin events from the server
      socket.on('spin', (spinData) => {
        if (spinning) return; // Prevent multiple spins

        const { spins, duration, stopAngle, winningSegment } = spinData;
        spinDuration = duration * 1000; // Convert to milliseconds
        targetAngle = (spins * 2 * Math.PI) + (stopAngle * Math.PI / 180);

        spinStartTime = null;
        spinSpeed = targetAngle / spinDuration; // Radians per millisecond
        spinning = true;
        animateSpin();
      });

      // Handle spinEnded events to reset spin state
      socket.on('spinEnded', (spinData) => {
        spinning = false;
      });

      // Animate the spin
      function animateSpin(timestamp) {
        if (!spinStartTime) spinStartTime = timestamp;
        const elapsed = timestamp - spinStartTime;

        if (elapsed < spinDuration) {
          currentAngle += spinSpeed * (timestamp - (spinStartTime || timestamp));
          spinStartTime = timestamp;
          drawWheel(currentAngle);
          animationFrameId = requestAnimationFrame(animateSpin);
        } else {
          currentAngle = targetAngle;
          drawWheel(currentAngle);
          spinning = false;
          cancelAnimationFrame(animationFrameId);
          // Determine the winning segment
          const normalizedAngle = currentAngle % (2 * Math.PI);
          const winningSegmentIndex = Math.floor((2 * Math.PI - normalizedAngle) / segmentAngle) % numSegments;
          alert(`The wheel stopped at: ${segments[winningSegmentIndex]}`);
        }
      }

      // Handle click on the wheel to initiate spin
      canvas.addEventListener('click', () => {
        if (!spinning) {
          socket.emit('spin', { wheelId });
          document.getElementById('statusMessage').innerText = 'Spinning...';
        }
      });
    }

    // Function to generate random colors
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }
  </script>
</body>
</html>
